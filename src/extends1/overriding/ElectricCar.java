package extends1.overriding;

import extends1.ex3.Car;

public class ElectricCar extends Car {

    @Override // Override 애노테이션을 붙여준다.
    // @Override가 없어도 있는 것처럼 동작은 하지만, 개발자들은 무조건 사용(권장, 코드의 명확성 증가)한다.
    // 애노테이션을 통해서 표식을 남기고, 만약 정확히 오버라이딩하지 않았을 경우 컴파일 오류가 발생한다.
    // 개발자의 실수를 확인할 수 있게 해준다.
    // 오버라이딩을 할 때는 리턴 타입까지 맞춰주어야 한다.
    public void move() {
        System.out.println("전기차를 빠르게 이동합니다.");
    }
    // 메서드 오버라이딩 즉, 메서드 재정의를 할 때에는 메서드를 재정의 한 후 @Override를 붙여준다.
    // 부모의 기능을 자식이 새로 재정의하는 것을 메서드 오버라이딩이라고 한다.
    // @ : 애노테이션, 애노테이션은 프로그램이 읽을 수 있는 특별한 주석이라고 생각하면 되고, 추후에 자세히 설명한다.
    // @Override, 애노테이션을 붙이면, 컴파일러는 메서드가 정확히 오버라이드 했는지를 확인한다.

    public void charge() {
        System.out.println("차를 충전합니다.");
    }
    
    // 오버로딩(Overloading)과 오버라이딩(Overriding)
    // 메서드 오버로딩
    //  - 메서드 이름이 같고 파라미터가 다른 메서드를 여러 개 정의하는 것
    //  - 직역하면 과적, 따라서 같은 이름의 메서드를 여러 개 정의했다고 이해하면 된다.
    
    // 메서드 오버라이딩
    //  - 하위 클래스에서 상위 클래스의 메서드를 재정의하는 것
    //  - 상속 관계에서 사용하며 부모의 기능을 자식이 다시 정의한다.
    //  - 직역하면 무언가를 넘어서 타는 것, 자식의 새로운 기능이 부모의 기존 기능을 넘어 타서 기존 기능을 새로운 기능으로 덮어버린다고 이해하면 된다.
    //  - 오버라이딩을 우리 말로 번역하면 무언가를 다시 정의한다고 해서 재정의라고 한다.
    //  - 상속 관계에서는 기존 기능을 다시 정의한다고 이해하면 되고, 실무에서는 메서드 오버라이딩과 재정의를 둘 다 사용한다.
    
    // 메서드 오버라이딩의 조건
    //  - 메서드 이름이 같아야 한다.
    //  - 메서드 파라미터(매개 변수)의 타입과 순서, 개수가 같아야 한다.

    //  - 반환 타입이 같이야 한다.
    //   - 이 때, 반환 타입이 하위 클래스 타입일 수 있다.
    //   - 부모의 반환 타입보다 더 구체적인 반환 타입이어도 된다는 것(부모 : Animal, 자식 : dog) 가능

    //  - 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다.
    //   - 범위가 더 넓어야 한다.

    //  - 예외, 오버라이딩 메서드는 상위 클래스의 메서드보다 더 많은 체크 예외를 throws로 선언할 수 없다.
    //   - 하지만 더 적거나 같은 수의 예외, 또는 하위 타입의 예외는 선언할 수 있다.
    //   - 이 부분은 뒤에서 다시 다룬다.

    //  - static, final, private 키워드가 붙은 메서드는 오버라이딩 될 수 없다.
    //   - static은 클래스 레벨에서 작동하므로 인스턴스 레벨에서 작동하는 오버라이딩이 의미가 없고, 그냥 클래스 이름을 통해 필요한 곳에 직접 접근하면 된다.
    //   - final에서는 재정의를 금지한다.
    //    - 메서드에 final이 붙으면 메서드를 고칠 수 없다는 것이기 때문이다.
    //   - private 메서드는 해당 클래스에서만 접근이 가능하기 때문에 하위 클래스에서 보이지 않아 오버라이딩 할 수 없다.

    //  - 생성자는 오버라이딩 할 수 없다.

    // 다만 지금은 단순하게 부모 메서드와 같은 메서드를 오버라이딩 할 수 있다 정도로 이해하면 된다.
    // @Override로 안전하게 사용하자

    // 접근 제어자의 UML 표기법
    // +(public), *(protected), ~(default), =(private)

    // private : 모든 외부 호출을 막는다.
    // default(package-private) : 같은 패키지 안에서 호출은 허용한다.
    // protected : 같은 패키지 안에서 호출 허용, 패키지가 달라도 상속 관계의 호출은 허용
    // public : 모든 외부 호출 허용
}

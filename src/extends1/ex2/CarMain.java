package extends1.ex2;

public class CarMain {
    public static void main(String[] args) {
        ElectricCar electricCar = new ElectricCar();
        electricCar.move(); // 부모클래스의 메서드를 사용(상속)
        electricCar.charge();

        GasCar gasCar = new GasCar();
        gasCar.move(); // 부모클래스의 메서드를 사용(상속)
        gasCar.fillUp();

        // 만약 본인한테 없을 경우 부모한테 올라가서 찾아 사용한다.
        // 상속은 부모의 기능을 자식이 물려받는 것이다.
        // 따라서 부모의 기능을 자식이 물려 받아 사용할 수 있지만, 반대로 부모 클래스는 자식 클래스에 접근할 수 없다.
        // 자식은 extends Parent(class)를 통해 부모를 알고 있기에 사용할 수 있는 것이다.
        // extends를 ->와 같은 화살표라고 생각하면 된다.

        // 단일 상속
        // 참고로 자바는 다중 상속을 지원하지 않는다.
        // 따라서 extends의 대상을 하나만 선택할 수 있다.
        //  - 부모의 메서드가 겹칠 경우, 어떤 메서드를 호출할 지 판단할 수 없기 때문이다(다이아몬드 문제).
        //  - 또한 다중 상속은 클래스의 계층 구조를 복잡하게 만들 수 있다.
        //  - 이러한 문제점들은 추후에 인터페이스의 다중 구현을 통해 해결한다.
        // 물론 부모가 또 다른 부모를 하나 가지는 것은 괜찮다.
        // 하나의 부모를 여러 자식이 갖는 것도 당연히 가능하다.
        
        // 상속과 메모리 구조(매우 중요)
        // 상속 관계를 객체로 생성할 때 메모리 구조를 알아보자

        // 만약 부모의 클래스를 상속 받는 자식의 객체를 생성하게 되면 자식과 부모 모두의 인스턴스를 생성한다.
        // 참조값은 하나이지만 실제로 그 안에는 두 가지 클래스 정보가 공존하는 것이다.
        // 이 때 본인과 부모가 둘 다 생성(메모리 공간 할당)되고 공간도 구분된다(참조값은 하나).
        // 그렇기에 메서드를 호출할 때, 부모 클래스에서 찾을 지 자식 클래스에서 찾을 지 선택해야 한다.
        //  - 호출하는 변수의 타입(클래스)를 기준으로 선택한다.
        //  - electricCar 변수의 타입이 ElectricCar 이므로 인스턴스 내부에 같은 타입인 ElectricCar를 통해서 charge()를 호출한다.
        //  - 즉 생성된 객체를 기준으로 해당 타입과 일치하는 클래스를 먼저 찾고, 없으면 다른 클래스를 찾는다.
        // 만약 부모에서도 해당 기능을 찾지 못하면 더 상위의 부모에서 필요한 기능을 찾고, 부모의 부모로 계속 올라가면서 찾아도 없으면 컴파일 오류가 발생한다.

        // 정리(매우 중요)
        // 상속 관계의 객체를 생성하면 그 내부에는 부모와 자식이 모두 생성된다.
        // 상속 관계의 객체를 호출할 때, 대상 타입(클래스)을 정해야 하는데 이 때, 호출자(객체)의 타입(클래스)을 통해 대상 타입(클래스)을 찾는다.
        // 현재 타입에서 기능을 찾지 못하면 상위 부모 타입으로 기능을 찾아서 실행하는데 만약 찾지 못하면 컴파일 오류가 발생한다.
    }
}
